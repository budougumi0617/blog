+++
title = "[Go] google/wireを使ったDependency Injectionデザイン #go"
date = 2018-12-14T09:25:57+09:00
draft = false
toc = true
comments = true
author = "budougumi0617"
categories = ["go"]
tags = ["golang", "wire"]
+++


これは[Go Advent Calendar 2018](https://qiita.com/advent-calendar/2018/go)の14日目の記事となる。
この記事ではgoogleが提供するGoのDependency Injection(DI、依存性の注入)ツールであるWireで利用できる関数について紹介する。

- google/wire
  - https://github.com/google/wire
- Compile-time Dependency Injection With Go Cloud's Wire
  - https://blog.golang.org/wire

<!--more-->

# TL;DR
- Wireコマンドはgoogle謹製のGoでDI（依存性の注入）を行なうツール
  - https://github.com/google/wire
- DIで利用できる関数の戻り値のパターンは4種類（引数は任意）
  - func() DIObject
  - func() (DIObject, error)
  - func() (DIObject, func())
  - func() (DIObject, func(), error)
- Wireを利用すると疎なpkg構成とDIコードの自動生成を享受できる

# 前置き：Wireについて
簡単に述べておくと、Wireはgoogleがgo-cloudのリポジトリを公開したときにそのリポジトリ内に同梱されていたDIツールだ。
[2018年12月](https://github.com/google/go-cloud/pull/831)にWireだけ別のリポジトリに分離され、独立して管理されるようになった。
次節から説明する`wire`pkgを使ったDIの組み合わせを定義して`go get`で入手できる`wire`コマンドを実行するとDIの初期化コードを自動生成できる。

```bash
$ go get github.com/google/wire/cmd/wire
$ wire -h
usage: wire [gen|diff|show|check] [...]
```


## Wireを使ったDIパーツの定義
Wireを使ったDIを利用するにはまず`wire.NewSet`を使ってDIのパーツ(Provider)を定義する必要がある。

[Defining Providers | Wire User Guide](https://github.com/google/wire/blob/master/docs/guide.md#defining-providers)より

```go
package foobarbaz

import (
    "github.com/google/wire"
)

type Foo struct {
    X int
}

// ProvideFoo はFoo構造体を提供するNew関数
func ProvideFoo() Foo {
    return Foo{X: 42}
}

type Bar struct {
    X int
}

// ProvideBar はFooを用いてBarを初期化するNew関数
func ProvideBar(foo Foo) Bar {
    return Bar{X: -foo.X}
}

type Baz struct {
    X int
}

// ProvideBaz はBarを利用してBazを初期化するNew関数
func ProvideBaz(ctx context.Context, bar Bar) (Baz, error) {
    if bar.X == 0 {
        return Baz{}, errors.New("cannot provide baz when bar is zero")
    }
    return Baz{X: bar.X}, nil
}

// wireを使ってFoo | Bar | Bazを提供するDIセットを定義する。
// Bazを取得するときは別にcontext.Contextを用意する必要がある。
var SuperSet = wire.NewSet(ProvideFoo, ProvideBar, ProvideBaz)
```

上記のサンプルコードの最後で定義しているのがWireの仕組み内でProviderと呼ばれるもので、このProviderを複数組み合わせることでDIの初期化をしていく。

## Wireを使ってDIの宣言

`wire.Build`を使ってDIで組み立てたいオブジェクトの構成要素を定義する。

[Injectors | Wire User Guide](https://github.com/google/wire/blob/master/docs/guide.md#injectors)より

```go
// +build wireinject
// このコードはgo buildには含まない

import (
    "context"

    "github.com/google/wire"
    "example.com/foobarbaz"
)

// SuperSetを使ってDI済みのBazを生成する。
func initializeBaz(ctx context.Context) (foobarbaz.Baz, error) {
    wire.Build(foobarbaz.SuperSet)
    return foobarbaz.Baz{}, nil
}
```

この例ではDI済みの`Baz`を生成する関数を定義している。
前述の中で定義した`SuperSet`では`Baz`オブジェクトを生成するための`context.Context`が自前で用意できないため、引数から`context.Context`を与えている。
なお、「このSetからXXXを生成するためには何を用意すればいいのか？」は`wire show`コマンドを使えば簡単に調べることができる。

```bash
wire show
"github.com/budougumi0617/foobarbaz".SuperSet
Outputs given no inputs:
        github.com/budougumi0617/foobarbaz.Bar
                at /Users/budougumi0617/go/src/github.com/budougumi0617/foobarbaz/foobarbaz.go:24:6
        github.com/budougumi0617/foobarbaz.Foo
                at /Users/budougumi0617/go/src/github.com/budougumi0617/foobarbaz/foobarbaz.go:15:6
Outputs given context.Context:
        github.com/budougumi0617/foobarbaz.Baz
                at /Users/budougumi0617/go/src/github.com/budougumi0617/foobarbaz/foobarbaz.go:33:6
```

## Wireを使ってDIの自動生成
先程の`initializeBaz`から実際に`go build`時に利用するDIコードを自動生成する。
`wire gen`コマンドを使って`initializeBaz`から自動生成されたコードが以下。

[Injectors | Wire User Guide](https://github.com/google/wire/blob/master/docs/guide.md#injectors)より
```go
// Code generated by Wire. DO NOT EDIT.

//go:generate wire
//+build !wireinject

package main

import (
    "example.com/foobarbaz"
)

func initializeBaz(ctx context.Context) (foobarbaz.Baz, error) {
    foo := foobarbaz.ProvideFoo()
    bar := foobarbaz.ProvideBar(foo)
    baz, err := foobarbaz.ProvideBaz(ctx, bar)
    if err != nil {
        return 0, err
    }
    return baz, nil
}
```

こうして`wire gen`コマンドを使うと、DI済みのオブジェクトを作成するコードを自動生成してくれる。
この`wire gen`を使ったDIのよいところは以下だと感じている。

- `wire.Build`関数に順不同でProviderを突っ込んでおいてもwireが適切な順序でDIしてくれる
- コード上の仕組みはシンプルなので後からでも導入できる。また逆に脱却も用意
- 「ただ依存性を解決するだけ」という知的生産性の無いコードをwireに一存できる

最後の利点については、例えばgo-cloudのサンプルコードを見るとその効果がわかりやすい。
go-cloudのサンプルコードではGCPを利用したWebサービスのDIをwireのInjectorの仕組みを使って以下のように設定している。
詳細は説明しないが、`Bucket`や`Cloud SQL`、`Stackdriver`の初期化をしたServerを構成するDIの定義だ。

[/github.com/google/go-cloud/samples/guestbook/inject_gcp.go](https://github.com/google/go-cloud/blob/3c405e2532f18716f030e35b1e99c2dffcb92a6e/samples/guestbook/inject_gcp.go#L37-L50)

```go
// setupGCP is a Wire injector function that sets up the application using GCP.
func setupGCP(ctx context.Context, flags *cliFlags) (*application, func(), error) {
	// This will be filled in by Wire with providers from the provider sets in
	// wire.Build.
	wire.Build(
		gcpcloud.GCP,
		cloudmysql.Open,
		applicationSet,
		gcpBucket,
		gcpMOTDVar,
		gcpSQLParams,
	)
	return nil, nil, nil
}
```

ここから`wire gen`を使って実際のDIコードを自動生成すると、70行近いDIコードが自動生成される（コードの掲載は省略する）。
依存関係が変更、あるいは追加されるたびにこのような依存関係を自動で再生成してくれるのは非常にありがたい。
（再生成前に`wire diff`コマンドを使って自動生成コードの差分を確認することも可能だ。）

[https://github.com/google/go-cloud/samples/guestbook/wire_gen.go#L105-L171](https://github.com/google/go-cloud/blob/3c405e2532f18716f030e35b1e99c2dffcb92a6e/samples/guestbook/wire_gen.go#L105-L171)

Wireとはどんなものなのか？についての詳細は以下の記事を参考にしていただきたい。

- [[発表資料]go-cloudとWireを利用したDI #gounco #go](/2018/10/19/presentation-gounco-lt4/)


# wireコマンドで利用できるproviderの定義
だいぶ前置きが長くなってしまったが、`wire.Set`で利用できるDI定義の関数には条件がある。
（注入する依存オブジェクトは各々で異なるので当然だが、）関数の引数には制限はないが、戻り値は４パターンしか認められていない。

## func() DIObject
１つ目は単純にDI済みのオブジェクトのみを返すパターンだ。

例: [github.com/google/go-cloud/gcp/gcp.go#L79](https://github.com/google/go-cloud/blob/129201bb98c1758a383cd059f0b5fe8d7920c9fa/gcp/gcp.go#L79)
```go
func CredentialsTokenSource(creds *google.Credentials) TokenSource
```

## func() (DIObject, error)
２つ目はDIに失敗したときに`error`を返す戻り値パターンだ。自動生成後のコード内で適切にエラーハンドリングするコードを生成してくれる。

例: [github.com/google/go-cloud/gcp/gcp.go#L70](https://github.com/google/go-cloud/blob/129201bb98c1758a383cd059f0b5fe8d7920c9fa/gcp/gcp.go#L70)
```go
func DefaultCredentials(ctx context.Context) (*google.Credentials, error)
```

## func() (DIObject, func())
３つ目は廃棄前に何らかのクリーンアップ処理が必要なDI済みのオブジェクトを生成する関数に対応するパターン。
例えば`*sql.DB`オブジェクトを生成する関数を用意するとして、`db.close`をクリーンアップ関数として返しておく。
そうすると、自動生成されたDIコードの中で`err != nil`だったとき適切にクリーンアップが行われる。
前掲した`setupGCP`のようにInjectorの戻り値に`func()`があればDI中に返されたクリーンアップ関数をDI済みオブジェクトと一緒に受け取ることも可能だ。

```go
func setupGCP(ctx context.Context, flags *cliFlags) (*application, func(), error)
```

例: [https://github.com/google/go-cloud/samples/guestbook/main.go#L313](https://github.com/google/go-cloud/blob/129201bb98c1758a383cd059f0b5fe8d7920c9fa/samples/guestbook/main.go#L313)
```
func appHealthChecks(db *sql.DB) ([]health.Checker, func())
```

## func() (DIObject, func(), error)
４つ目は異常がなかったときはDIオブジェクトとクリーンアップ関数を返し、異常時は`error`を返すパターン。
実際に定義する際は３つめのパターンよりこの宣言になることのほうが多いだろう。

例: [https://github.com/google/go-cloud/mysql/rdsmysql/rdsmysql.go#L60](https://github.com/google/go-cloud/blob/129201bb98c1758a383cd059f0b5fe8d7920c9fa/mysql/rdsmysql/rdsmysql.go#L60)
```go
func appHealthChecks(db *sql.DB) ([]health.Checker, func())
```

# 終わりに
今回は`Wire`を使ったDIの利点と`Wire`で利用可能なDI関数の戻り値パターンを紹介した。
プリミティブな値を含んだDIをするときは型エイリアスを適切に切っておく、などいくつかのプラクティスがあるのだが、それらはリポジトリのdocsを確認すればよい。

- Best Practices
  - https://github.com/google/wire/blob/master/docs/best-practices.md

実際にWireを使ったサンプルコードについては以下を参照するといいと思う。

- https://github.com/google/go-cloud/tree/master/samples/guestbook
- https://github.com/terashi58/wire-example

なお、プロダクトで利用している事例は私の同僚のterashiさんが書いた以下のブログ記事が詳しい。

- freeeのマイクロサービス基盤とWire導入
  - https://developers.freee.co.jp/entry/service-infra-and-wire

# 参考
- google/wire
  - https://github.com/google/wire
- Compile-time Dependency Injection With Go Cloud's Wire
  - https://blog.golang.org/wire
- freeeのマイクロサービス基盤とWire導入
  - https://developers.freee.co.jp/entry/service-infra-and-wire

# 関連
- [[発表資料]go-cloudとWireを利用したDI #gounco #go](/2018/10/19/presentation-gounco-lt4/)



------------------
# memo
ワイヤーがいいよ
くわしくは以下のブログで
ワイヤーに使える関数について
三種類の形
まとめ
ワイヤーで利用できる関数についてまとめた。
ワイヤーを使えば自然と疎なパッケージ構成を作ることもでき、テストもしやすい。また面倒なインジェクションのコードを自動生成することができる。
